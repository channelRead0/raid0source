#pragma once
#include "pch.h"

typedef struct VMStructEntry
{
    const char* TypeName;    
    const char* FieldName;       
    const char* TypeString;      

    int32_t IsStatic;              
    uint64_t Offset;             

    void* Address;               
};

typedef struct VMTypeEntry
{
    const char* TypeName;            
    const char* SuperClassName;     

    int32_t IsOopType;             
    int32_t IsIntegerType;         
    int32_t IsUnsigned;           

    uint64_t Size;                
};

typedef struct VMIntConstantEntry
{
    const char* Name;                

    int32_t Value;                
};

typedef struct VMLongConstantEntry
{
    const char* Name;                

    uint64_t Value;                 
};

typedef struct VMAddressEntry
{
    const char* Name;              

    void* Value;                  
};

enum Flags
{
    _FLAG_CallerSensitive = 1 << 0,
    _FLAG_ForceInline = 1 << 1,
    _FLAG_DontInline = 1 << 2,
    _FLAG_Hidden = 1 << 3,
    _FLAG_HasInjectedProfile = 1 << 4,
    _FLAG_IntrinsicCandidate = 1 << 5,
    _FLAG_ReservedAtackAccess = 1 << 6,
    _FLAG_Scoped = 1 << 7
};

enum JavaAccessFlags
{
    JVM_ACC_WRITTEN_FLAGS = 0x00007FFF,

    // Method* flags
    JVM_ACC_MONITOR_MATCH = 0x10000000,     // True if we know that monitorenter/monitorexit bytecodes match
    JVM_ACC_HAS_MONITOR_BYTECODES = 0x20000000,     // Method contains monitorenter/monitorexit bytecodes
    JVM_ACC_HAS_LOOPS = 0x40000000,     // Method has loops
    JVM_ACC_LOOPS_FLAG_INIT = (int)0x80000000,// The loop flag has been initialized
    JVM_ACC_QUEUED = 0x01000000,     // Queued for compilation
    JVM_ACC_NOT_C2_COMPILABLE = 0x02000000,
    JVM_ACC_NOT_C1_COMPILABLE = 0x04000000,
    JVM_ACC_NOT_C2_OSR_COMPILABLE = 0x08000000,
    JVM_ACC_HAS_LINE_NUMBER_TABLE = 0x00100000,
    JVM_ACC_HAS_CHECKED_EXCEPTIONS = 0x00400000,
    JVM_ACC_HAS_JSRS = 0x00800000,
    JVM_ACC_IS_OLD = 0x00010000,     // RedefineClasses() has replaced this method
    JVM_ACC_IS_OBSOLETE = 0x00020000,     // RedefineClasses() has made method obsolete
    JVM_ACC_IS_PREFIXED_NATIVE = 0x00040000,     // JVMTI has prefixed this native method
    JVM_ACC_ON_STACK = 0x00080000,     // RedefineClasses() was used on the stack
    JVM_ACC_IS_DELETED = 0x00008000,     // RedefineClasses() has deleted this method

    // Klass* flags
    JVM_ACC_HAS_MIRANDA_METHODS = 0x10000000,     // True if this class has miranda methods in it's vtable
    JVM_ACC_HAS_VANILLA_CONSTRUCTOR = 0x20000000,     // True if klass has a vanilla default constructor
    JVM_ACC_HAS_FINALIZER = 0x40000000,     // True if klass has a non-empty finalize() method
    JVM_ACC_IS_CLONEABLE_FAST = (int)0x80000000,// True if klass implements the Cloneable interface and can be optimized in generated code
    JVM_ACC_HAS_FINAL_METHOD = 0x01000000,     // True if klass has final method
    JVM_ACC_IS_SHARED_CLASS = 0x02000000,     // True if klass is shared
    JVM_ACC_IS_HIDDEN_CLASS = 0x04000000,     // True if klass is hidden
    JVM_ACC_IS_VALUE_BASED_CLASS = 0x08000000,     // True if klass is marked as a ValueBased class

    // Klass* and Method* flags
    JVM_ACC_HAS_LOCAL_VARIABLE_TABLE = 0x00200000,

    JVM_ACC_PROMOTED_FLAGS = 0x00200000,    

    // Field flags
    JVM_ACC_FIELD_ACCESS_WATCHED = 0x00002000, // field access is watched by JVMTI
    JVM_ACC_FIELD_MODIFICATION_WATCHED = 0x00008000, // field modification is watched by JVMTI
    JVM_ACC_FIELD_INTERNAL = 0x00000400, // internal field, same as JVM_ACC_ABSTRACT
    JVM_ACC_FIELD_STABLE = 0x00000020, // @Stable field, same as JVM_ACC_SYNCHRONIZED and JVM_ACC_SUPER
    JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE = 0x00000100, // (static) final field updated outside (class) initializer, same as JVM_ACC_NATIVE
    JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE = 0x00000800, // field has generic signature

    JVM_ACC_FIELD_INTERNAL_FLAGS = JVM_ACC_FIELD_ACCESS_WATCHED |
    JVM_ACC_FIELD_MODIFICATION_WATCHED |
    JVM_ACC_FIELD_INTERNAL |
    JVM_ACC_FIELD_STABLE |
    JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE,

    JVM_ACC_PUBLIC = 0x0001,  /* visible to everyone */
    JVM_ACC_PRIVATE = 0x0002,  /* visible only to the defining class */
    JVM_ACC_PROTECTED = 0x0004,  /* visible to subclasses */
    JVM_ACC_STATIC = 0x0008,  /* instance variable is static */
    JVM_ACC_FINAL = 0x0010,  /* no further subclassing, overriding */
    JVM_ACC_SYNCHRONIZED = 0x0020,  /* wrap method call in monitor lock */
    JVM_ACC_SUPER = 0x0020,  /* funky handling of invokespecial */
    JVM_ACC_VOLATILE = 0x0040,  /* can not cache in registers */
    JVM_ACC_BRIDGE = 0x0040,  /* bridge method generated by compiler */
    JVM_ACC_TRANSIENT = 0x0080,  /* not persistent */
    JVM_ACC_VARARGS = 0x0080,  /* method declared with variable number of args */
    JVM_ACC_NATIVE = 0x0100,  /* implemented in C */
    JVM_ACC_INTERFACE = 0x0200,  /* class is an interface */
    JVM_ACC_ABSTRACT = 0x0400,  /* no definition provided */
    JVM_ACC_STRICT = 0x0800,  /* strict floating point */
    JVM_ACC_SYNTHETIC = 0x1000,  /* compiler-generated class, method or field */
    JVM_ACC_ANNOTATION = 0x2000,  /* annotation type */
    JVM_ACC_ENUM = 0x4000  /* field is declared as element of enum */
};

enum JavaThreadState
{
    _THREAD_Uninitialized = 0, // should never happen (missing initialization)
    _THREAD_New = 2, // just starting up, i.e., in process of being initialized
    _THREAD_NewTrans = 3, // corresponding transition state (not used, included for completness)
    _THREAD_InNative = 4, // running in native code
    _THREAD_InNativeTrans = 5, // corresponding transition state
    _THREAD_InVm = 6, // running in VM
    _THREAD_InVmrans = 7, // corresponding transition state
    _THREAD_InJava = 8, // running in Java or in stub code
    _THREAD_InJavaTrans = 9, // corresponding transition state (not used, included for completness)
    _THREAD_Blocked = 10, // blocked in vm
    _THREAD_BlockedTrans = 11, // corresponding transition state
    _THREAD_MaxState = 12  // maximum THREAD state+1 - used for statistics allocation
};

extern "C" JNIIMPORT VMStructEntry* gHotSpotVMStructs;
extern "C" JNIIMPORT VMTypeEntry* gHotSpotVMTypes;
extern "C" JNIIMPORT VMIntConstantEntry* gHotSpotVMIntConstants;
extern "C" JNIIMPORT VMLongConstantEntry* gHotSpotVMLongConstants;

inline bool InitializeHotspot()
{
    if (!gHotSpotVMStructs || !gHotSpotVMTypes || !gHotSpotVMIntConstants || !gHotSpotVMLongConstants)
    {
        return false;
    }

    return true;
}

static VMStructEntry* FindVMStructEntry(const char* TypeName, const char* FieldName, bool IsStatic)
{
    for (VMStructEntry* VMEntry = gHotSpotVMStructs; VMEntry->TypeName != nullptr; ++VMEntry)
    {
        if (TypeName && std::strcmp(TypeName, VMEntry->TypeName)) continue;
        if (FieldName && std::strcmp(FieldName, VMEntry->FieldName)) continue;
        if (IsStatic != (bool)VMEntry->IsStatic) continue;

      /*  std::clog << 
        "[+] Found VMStructEntry: \n"
        "type: " << TypeName << "\n"
        "field: " << FieldName << "\n"
        "static: " << (IsStatic ? "true" : "false") << "\n"
        "address: " << VMEntry->Address << "\n"
        "offset: " << VMEntry->Offset << "\n\n";*/

        return VMEntry;
    }

   /* std::cerr << 
    "[-] Failed to find VMStructEntry: \n"
    "type: " << TypeName << "\n"
    "field: " << FieldName << "\n"
    "static: " << (IsStatic ? "true" : "false") << "\n\n";*/

    return nullptr;
}

static VMStructEntry* FindVMStructEntry(const char* FieldName, bool IsStatic)
{
    for (VMStructEntry* VMEntry = gHotSpotVMStructs; VMEntry->TypeName != nullptr; ++VMEntry)
    {
        if (FieldName && std::strcmp(FieldName, VMEntry->FieldName)) continue;
        if (IsStatic != (bool)VMEntry->IsStatic) continue;

        /*std::clog << 
        "[+] Found VMStructEntry: \n"
        "type: " << VMEntry->TypeName << "\n"
        "field: " << FieldName << "\n"
        "static: " << (IsStatic ? "true" : "false") << "\n"
        "address: " << VMEntry->Address << "\n"
        "offset: " << VMEntry->Offset << "\n\n";*/
        return VMEntry;
    }
    return nullptr;
}

static VMTypeEntry* FindVMTypeEntry(const char* TypeName)
{
    for (VMTypeEntry* VMEntry = gHotSpotVMTypes; VMEntry->TypeName != nullptr; ++VMEntry)
    {
        if (TypeName && std::strcmp(TypeName, VMEntry->TypeName)) continue;
       /* if (TypeName && std::strcmp(TypeName, VMEntry->TypeName)) continue;
        std::clog << "[+] Found VMTypeEntry: \n"
            "type: " << TypeName << "\n";*/
        return VMEntry;
    }
  /*  std::cerr << "[-] Failed to find VMTypeEntry: \n"
        "type: " << TypeName << "\n\n";*/
    return nullptr;
}

static VMIntConstantEntry* FindVMIntConstantEntry(const char* ConstantName)
{
    if (!ConstantName || !gHotSpotVMIntConstants) return nullptr;
    for (VMIntConstantEntry* VMEntry = gHotSpotVMIntConstants; VMEntry->Name != nullptr; ++VMEntry)
    {
        if (std::strcmp(ConstantName, VMEntry->Name)) continue;

        /*std::clog << 
        "[+] Found VMIntConstantEntry: \n"
        "name: " << VMEntry->Name << "\n"
        "value: " << VMEntry->Value << "\n\n";*/

        return VMEntry;
    }

  /*  std::cerr << 
    "[-] Failed to find VMTypeEntry: \n"
    "name: " << ConstantName << "\n\n"
        ;*/
    return nullptr;
}

static VMLongConstantEntry* FindVMLongConstantEntry(const char* ConstantName)
{
    if (!ConstantName || !gHotSpotVMLongConstants) return nullptr;
    for (VMLongConstantEntry* VMEntry = gHotSpotVMLongConstants; VMEntry->Name != nullptr; ++VMEntry)
    {
        if (std::strcmp(ConstantName, VMEntry->Name)) continue;

      /*  std::clog <<
        "[+] Found VMLongConstantEntry: \n"
        "name: " << VMEntry->Name << "\n"
        "value: " << VMEntry->Value << "\n\n";*/

        return VMEntry;
    }

   /* std::cerr << 
    "[-] Failed to find VMLongEntry: \n"
    "name: " << ConstantName << "\n\n";*/

    return nullptr;
}

struct DirectoryEntry
{
    DirectoryEntry* GetNext()
    {
        static VMStructEntry* NextEntry = FindVMStructEntry("BasicHashtableEntry<mtInternal>", "_next", false);
        if (!NextEntry) return nullptr;

        return (DirectoryEntry*)(*(intptr_t*)((uint8_t*)this + NextEntry->Offset) & -2);
    }

    void* GetLiteral()
    {
        static VMStructEntry* LiteralEntry = FindVMStructEntry("IntptrHashtableEntry", "_literal", false);
        if (!LiteralEntry) return nullptr;

        return *(void**)((uint8_t*)this + LiteralEntry->Offset);
    }
};

struct Dictionary
{
    DirectoryEntry** GetBuckets()
    {
        static VMStructEntry* BucketsEntry = FindVMStructEntry("BasicHashtable<mtInternal>", "_buckets", false);
        if (!BucketsEntry) return nullptr;

        return *(DirectoryEntry***)((uint8_t*)this + BucketsEntry->Offset);
    }
    int GetTableSize()
    {
        static VMStructEntry* TableSizeEntry = FindVMStructEntry("BasicHashtable<mtInternal>", "_table_size", false);
        if (!TableSizeEntry) return 0;

        return *(int*)((uint8_t*)this + TableSizeEntry->Offset);
    }
};

struct Symbol
{
    std::string ToString()
    {
        static VMStructEntry* BodyEntry = FindVMStructEntry("Symbol", "_body", false);
        if (!BodyEntry) return "";

        static VMStructEntry* LengthEntry = FindVMStructEntry("Symbol", "_length", false);
        if (!LengthEntry) return "";

        unsigned char* Body = (uint8_t*)this + BodyEntry->Offset;
        unsigned short Length = *(unsigned short*)((uint8_t*)this + LengthEntry->Offset);
        
        return std::string((char*)Body, Length);
    }
};

struct ConstantPool
{
    void** GetBase()
    {
        if (!this) return nullptr;

        int Size = GetSize();
        if (!Size) return nullptr;

        return (void**)((uint8_t*)this + Size);
    }

    static int GetSize()
    {
        static VMTypeEntry* ConstantPoolEntry = FindVMTypeEntry("ConstantPool");
        if (!ConstantPoolEntry) return 0;

        return (int)ConstantPoolEntry->Size;
    }

    int GetLength()
    {
        if (!this) return 0;

        static VMStructEntry* ConstantPoolEntry = FindVMStructEntry("ConstantPool", "_length", false);
        if (!ConstantPoolEntry) return 0;

        return *(int*)((uint8_t*)this + ConstantPoolEntry->Offset);
    }
};

struct ConstMethod
{
    ConstantPool* GetConstants()
    {
        if (!this) return nullptr;

        static VMStructEntry* ConstantsEntry = FindVMStructEntry("ConstMethod", "_constants", false);
        if (!ConstantsEntry) return nullptr;

        return *(ConstantPool**)((uint8_t*)this + ConstantsEntry->Offset);
    }

    void SetConstants(ConstantPool* Constants)
    {
        if (!this) return;

        static VMStructEntry* ConstantsEntry = FindVMStructEntry("ConstMethod", "_constants", false);
        if (!ConstantsEntry) return;

        *(ConstantPool**)((uint8_t*)this + ConstantsEntry->Offset) = Constants;
    }

    unsigned short GetNameIndex()
    {
        if (!this) return 0;

        static VMStructEntry* NameIndexEntry = FindVMStructEntry("ConstMethod", "_name_index", false);
        if (!NameIndexEntry) return 0;

        return *(unsigned short*)((uint8_t*)this + NameIndexEntry->Offset);
    }

    unsigned short GetSignatureIndex()
    {
        if (!this) return 0;

        static VMStructEntry* SignatureIndexEntry = FindVMStructEntry("ConstMethod", "_signature_index", false);
        if (!SignatureIndexEntry) return 0;

        return *(unsigned short*)((uint8_t*)this + SignatureIndexEntry->Offset);
    }
};

struct AccessFlags
{
    jint Flags;

    bool IsStatic() {
        return (Flags & JVM_ACC_STATIC) != 0;
    }
};

struct Method
{
    ConstMethod* GetConstMethod()
    {
        if (!this) return nullptr;

        static VMStructEntry* ConstMethodEntry = FindVMStructEntry("Method", "_constMethod", false);
        if (!ConstMethodEntry) return nullptr;

        return *(ConstMethod**)((uint8_t*)this + ConstMethodEntry->Offset);
    }

    std::string GetSignature()
    {
        if (!this) return "";

        ConstMethod* ConstMethod = this->GetConstMethod();

        int SignatureIndex = ConstMethod->GetSignatureIndex();

        ConstantPool* ConstantPool = ConstMethod->GetConstants();
        Symbol** Base = (Symbol**)ConstantPool->GetBase();

        return Base[SignatureIndex]->ToString();
    }

    std::string GetName()
    {
        if (!this) return "";

        ConstMethod* ConstMethod = this->GetConstMethod();

        int NameIndex = ConstMethod->GetNameIndex();

        ConstantPool* ConstantPool = ConstMethod->GetConstants();
        Symbol** Base = (Symbol**)ConstantPool->GetBase();

        return Base[NameIndex]->ToString();
    }

    int GetParametersCount()
    {
        std::string Signature = GetSignature();

        if (Signature.empty()) return 0;

        Signature = Signature.substr(1, Signature.find(')') - 1);

        int ParamCount = 0;
        for (size_t Index = 0; Index < Signature.size(); ++Index)
        {
            char Char = Signature[Index];
            if (Char == 'L') {
                Index = Signature.find(';', Index);
            }
            ++ParamCount;
        }

        return ParamCount;
    }

    AccessFlags* GetAccessFlags()
    {
        if (!this) return nullptr;

        static VMStructEntry* AccessFlagsEntry = FindVMStructEntry("Method", "_access_flags", false);
        if (!AccessFlagsEntry) return nullptr;

        return (AccessFlags*)((uint8_t*)this + AccessFlagsEntry->Offset);
    }

    void* GetFromInterpretedEntry()
    {
        static VMStructEntry* VMEntry = FindVMStructEntry("Method", "_from_interpreted_entry", false);
        if (!VMEntry) return nullptr;

        return *(void**)((uint8_t*)this + VMEntry->Offset);
    }

    void SetFromInterpretedEntry(void* Entry)
    {
        static VMStructEntry* VMEntry = FindVMStructEntry("Method", "_from_interpreted_entry", false);
        if (!VMEntry) return;

        *(void**)((uint8_t*)this + VMEntry->Offset) = Entry;
        return;
    }

    void* GetFromCompiledEntry()
    {
        static VMStructEntry* VMEntry = FindVMStructEntry("Method", "_from_compiled_entry", false);
        if (!VMEntry) return nullptr;

        return *(void**)((uint8_t*)this + VMEntry->Offset);
    }

    void SetFromCompiledEntry(void* Entry)
    {
        static VMStructEntry* VMEntry = FindVMStructEntry("Method", "_from_compiled_entry", false);
        if (!VMEntry) return;

        *(void**)((uint8_t*)this + VMEntry->Offset) = Entry;
        return;
    }

    void* Geti2iEntry()
    {
        static VMStructEntry* VMEntry = FindVMStructEntry("Method", "_i2i_entry", false);
        if (!VMEntry) return nullptr;

        return *(void**)((uint8_t*)this + VMEntry->Offset);
    }

    unsigned short* GetFlags()
    {
        if (!this) return nullptr;
        static VMStructEntry* VMEntry = FindVMStructEntry("Method", "_flags", false);
        if (!VMEntry)
            return nullptr;
        return (unsigned short*)((uint8_t*)this + VMEntry->Offset);
    }

    void SetDontInline(bool Enabled)
    {
        unsigned short* _Flags = GetFlags();
        if (!_Flags)
        {
            static VMStructEntry* VMEntry = FindVMStructEntry("Method", "_intrinsic_id", false);

            if (!VMEntry) return;

            unsigned char* Flags = ((uint8_t*)this + VMEntry->Offset + 1);

            if (Enabled) {
                *Flags |= (1 << 4);
            }
            else {
                *Flags &= ~(1 << 4);
            }
            return;
        }

        if (Enabled) {
            *_Flags |= _FLAG_DontInline;
        }
        else {
            *_Flags &= ~_FLAG_DontInline;
        }
    }
};

struct Array
{
    int GetLength()
    {
        if (!this) return 0;

        static VMStructEntry* LengthEntry = FindVMStructEntry("Array<Klass*>", "_length", false);
        if (!LengthEntry) return 0;

        return *(int*)((uint8_t*)this + LengthEntry->Offset);
    }

    void** GetData()
    {
        if (!this) return nullptr;

        static VMStructEntry* DataEntry = FindVMStructEntry("Array<Klass*>", "_data", false);
        if (!DataEntry) return nullptr;

        return (void**)((uint8_t*)this + DataEntry->Offset);
    }
};

struct ArrayU2
{
    int GetLength()
    {
        if (!this) return 0;

        static VMStructEntry* LengthEntry = FindVMStructEntry("Array<Klass*>", "_length", false);
        if (!LengthEntry) return 0;

        return *(int*)((uint8_t*)this + LengthEntry->Offset);
    }

    unsigned short* GetData()
    {
        if (!this) return nullptr;

        static VMStructEntry* DataEntry = FindVMStructEntry("Array<u2>", "_data", false);
        if (!DataEntry) return nullptr;

        return (unsigned short*)((uint8_t*)this + DataEntry->Offset);
    }
};

struct Thread
{
    JNIEnv* GetEnv()
    {
        if (!this) return nullptr;

        static VMStructEntry* AnchorEntry = FindVMStructEntry("JavaThread", "_anchor", false);
        if (!AnchorEntry) return nullptr;

        return (JNIEnv*)((uint8_t*)this + AnchorEntry->Offset + 32);
    }

    uint32_t GetSuspendFlags()
    {
        static VMStructEntry* VMEntry = FindVMStructEntry("Thread", "_suspend_flags", false);
        if (!VMEntry) return 0;

        return *(uint32_t*)((uint8_t*)this + VMEntry->Offset);
    }

    JavaThreadState GetThreadState()
    {
        if (!this) return _THREAD_Uninitialized;

        return *(JavaThreadState*)((uint8_t*)this + GetThreadStateOffset());
    }

    void SetThreadState(JavaThreadState State)
    {
        if (!this) return;

        *(JavaThreadState*)((uint8_t*)this + GetThreadStateOffset()) = State;
    }

    static int GetThreadStateOffset()
    {
        static VMStructEntry* VMEntry = FindVMStructEntry("JavaThread", "_thread_state", false);

        if (!VMEntry)
            return 0;

        return (int)VMEntry->Offset;
    }
};

struct Klass
{
    Symbol* GetName()
    {
        if (!this) return nullptr;

        static VMStructEntry* NameEntry = FindVMStructEntry("Klass", "_name", false);
        if (!NameEntry) return nullptr;

        Symbol* Name = *(Symbol**)((uint8_t*)this + NameEntry->Offset);
        return Name;
    }

    Method* FindMethod(const std::string& MethodName, const std::string& MethodSignature) 
    {
        Array* Methods = GetMethods();
        Method** Data = (Method**)Methods->GetData();
        int Length = Methods->GetLength();
        for (int i = 0; i < Length; ++i)
        {
            Method* Method = Data[i];

            ConstMethod* ConstMethod = Method->GetConstMethod();
            ConstantPool* ConstPool = ConstMethod->GetConstants();

            void** Base = ConstPool->GetBase();

            unsigned short NameIndex = ConstMethod->GetNameIndex();
            unsigned short SignatureIndex = ConstMethod->GetSignatureIndex();

            Symbol* SymbolName = (Symbol*)Base[NameIndex];
            Symbol* SymbolSignature = (Symbol*)Base[SignatureIndex];

            const std::string& Name = SymbolName->ToString();
            const std::string& Signature = SymbolSignature->ToString();

            if (Name == MethodName && Signature == MethodSignature) {
                return Method;
            }
        }
        return nullptr;
    }
    ArrayU2* GetFields()
    {
        if (!this) return nullptr;

        static VMStructEntry* FieldsEntry = FindVMStructEntry("InstanceKlass", "_fields", false);
        if (!FieldsEntry) return nullptr;

        return *(ArrayU2**)((uint8_t*)this + FieldsEntry->Offset);
    }

    Array* GetMethods() 
    {
        if (!this) return nullptr;

        static VMStructEntry* MethodsEntry = FindVMStructEntry("InstanceKlass", "_methods", false);
        if (!MethodsEntry) return nullptr;

        return *(Array**)((uint8_t*)this + MethodsEntry->Offset);
    }

    ConstantPool* GetConstants() 
    {
        if (!this) return nullptr;

        static VMStructEntry* ConstantsEntry = FindVMStructEntry("InstanceKlass", "_constants", false);
        if (!ConstantsEntry) return nullptr;

        return *(ConstantPool**)((uint8_t*)this + ConstantsEntry->Offset);
    }
};

struct FieldInfo
{
    unsigned short Data[6];

    unsigned short GetNameIndex()
    {
        return Data[1];
    }
    unsigned short GetSignatureIndex()
    {
        return Data[2];
    }
    unsigned short GetAccess() 
    { 
        return Data[0];
    }

    bool IsInternal()
    {
        return (GetAccess() & JVM_ACC_FIELD_INTERNAL) != 0;
    }
    bool IsPublic() 
    {
        return (GetAccess() & JVM_ACC_PUBLIC) != 0;
    }
    bool IsPrivate()
    {
        return (GetAccess() & JVM_ACC_PRIVATE) != 0;
    }
    bool IsProtected() 
    {
        return (GetAccess() & JVM_ACC_PROTECTED) != 0;
    }
    bool IsStatic() 
    {
        return (GetAccess() & JVM_ACC_STATIC) != 0;
    }
    bool IsFinal() 
    { 
        return (GetAccess() & JVM_ACC_FINAL) != 0;
    }
};

struct Frame
{
    inline static int LocalsOffset = -56;

    void** GetLocals()
    {
        if (!this) return nullptr;

        return *(void***)((uint8_t*)this + LocalsOffset); //48 on java8, 56 on java17
    }
    Method* GetMethod()
    { 
        if (!this) return nullptr;

        return *(Method**)((uint8_t*)this - 24);
    }
};

class MemoryModule
{
public:
    MemoryModule(const char* module_name) :
        MemoryModule(GetModuleHandleA(module_name))
    {
    }

    MemoryModule(HMODULE a_module) :
        module(a_module)
    {
        GetModuleInformation(GetCurrentProcess(), module, &moduleInfo, sizeof(MODULEINFO));
    }

    uint8_t* pattern_scan(uint8_t pattern[], int size, int access) const
    {
        MEMORY_BASIC_INFORMATION memInfo{};
        for (uint8_t* ptr = (uint8_t*)moduleInfo.lpBaseOfDll;
            ptr < (uint8_t*)moduleInfo.lpBaseOfDll + moduleInfo.SizeOfImage && VirtualQuery(ptr, &memInfo, sizeof(MEMORY_BASIC_INFORMATION));
            ptr = (uint8_t*)memInfo.BaseAddress + memInfo.RegionSize
            )
        {
            if (memInfo.Protect != access)
                continue;
            uint8_t* region_end_addr = (uint8_t*)memInfo.BaseAddress + memInfo.RegionSize;
            for (uint8_t* rg_ptr = (uint8_t*)memInfo.BaseAddress;
                rg_ptr < region_end_addr;)
            {
                int matches = 0;
                for (int i = 0; i < size; i++)
                {
                    if (pattern[i] == rg_ptr[i])
                        matches++;
                    else
                        break;
                }
                if (matches == size)
                    return rg_ptr;
                rg_ptr += (matches > 1 ? matches : 1);
            }
        }
        return nullptr;
    }

    std::vector<uint8_t*> pattern_scan_all(uint8_t pattern[], int size, int access) const
    {
        std::vector<uint8_t*> results{};
        MEMORY_BASIC_INFORMATION memInfo{};
        for (uint8_t* ptr = (uint8_t*)moduleInfo.lpBaseOfDll;
            ptr < (uint8_t*)moduleInfo.lpBaseOfDll + moduleInfo.SizeOfImage && VirtualQuery(ptr, &memInfo, sizeof(MEMORY_BASIC_INFORMATION));
            ptr = (uint8_t*)memInfo.BaseAddress + memInfo.RegionSize
            )
        {
            if (memInfo.Protect != access)
                continue;
            uint8_t* region_end_addr = (uint8_t*)memInfo.BaseAddress + memInfo.RegionSize;
            for (uint8_t* rg_ptr = (uint8_t*)memInfo.BaseAddress;
                rg_ptr < region_end_addr;)
            {
                int matches = 0;
                for (int i = 0; i < size; i++)
                {
                    if (pattern[i] == rg_ptr[i])
                        matches++;
                    else
                        break;
                }
                if (matches == size)
                {
                    results.push_back(rg_ptr);
                }
                rg_ptr += (matches > 1 ? matches : 1);
            }
        }
        return results;
    }

    uint8_t* pattern_scan_text_section(uint8_t* const pattern_start, const int pattern_size, const uint8_t wildcard) const
    {
        if (!module) return nullptr;

        for (PIMAGE_SECTION_HEADER section : get_section_headers())
        {
            if (!(section->Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE))) continue;
            uint8_t* search_start = (uint8_t*)module + section->VirtualAddress;
            uint8_t* search_end = search_start + section->SizeOfRawData;
            for (uint8_t* curr = search_start; curr < search_end; ++curr)
            {
                for (int i = 0; i < pattern_size; ++i)
                {
                    if (curr[i] != pattern_start[i] && pattern_start[i] != wildcard)
                        break;
                    if (i == pattern_size - 1)
                        return curr;
                }
            }
        }
        return nullptr;
    }

    void* getProcAddress(const char* name)
    {
        return GetProcAddress(module, name);
    }

    operator bool() const
    {
        return module && moduleInfo.lpBaseOfDll;
    }

    static uint8_t* AllocateNearbyMemory(uint8_t* nearby_addr, int size, int access)
    {
        for (int i = 65536;
            i < 0x7FFFFFFF;
            i += 65536)
        {
            uint8_t* allocated = (uint8_t*)VirtualAlloc(nearby_addr + i, size, MEM_COMMIT | MEM_RESERVE, access);
            if (allocated)
                return allocated;
            allocated = (uint8_t*)VirtualAlloc(nearby_addr - i, size, MEM_COMMIT | MEM_RESERVE, access);
            if (allocated)
                return allocated;
        }
        return nullptr;
    }

private:
    MODULEINFO moduleInfo{};
    HMODULE module = nullptr;


    PIMAGE_NT_HEADERS get_nt_headers() const
    {
        PIMAGE_DOS_HEADER dos_header = (PIMAGE_DOS_HEADER)module;
        return (PIMAGE_NT_HEADERS)((uint8_t*)module + dos_header->e_lfanew);
    }

    std::vector<PIMAGE_SECTION_HEADER> get_section_headers() const
    {
        PIMAGE_NT_HEADERS nt_headers = get_nt_headers();
        int number_of_sections = nt_headers->FileHeader.NumberOfSections;
        std::vector<PIMAGE_SECTION_HEADER> section_headers{};
        section_headers.reserve(number_of_sections);

        PIMAGE_OPTIONAL_HEADER optional_header = &nt_headers->OptionalHeader;
        PIMAGE_SECTION_HEADER section = (PIMAGE_SECTION_HEADER)((uint8_t*)optional_header + nt_headers->FileHeader.SizeOfOptionalHeader);

        for (int i = 0; i < number_of_sections; ++i, ++section)
        {
            section_headers.push_back(section);
        }

        return section_headers;
    }
};

typedef void(*i2iDetourT)(Frame* Frame, Thread* Thread, bool* Cancel);
class Midi2iHook
{
public:
    Midi2iHook(uint8_t* Target, i2iDetourT Detour) : Target(Target)
    {
        constexpr int HOOK_SIZE = 8;
        constexpr int JMP_SIZE = 5;
        constexpr int JE_OFFSET = 0x3d;
        constexpr int JE_SIZE = 6;
        constexpr int DETOUR_ADDRESS_OFFSET = 0x56;

        uint8_t Assembly[] =
        {
            0x50, 0x51, 0x52, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x55, 0x6A, 0x00, 0x48, 0x89, 0xE9, 0x4C, 0x89, 0xFA, 0x4C, 0x8D, 0x04,
            0x24, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xE4, 0xF0, 0x48, 0x83, 0xEC, 0x20, 0xFF, 0x15, 0x2D, 0x00, 0x00, 0x00, 0x48, 0x89, 0xEC, 0x58, 0x48,
            0x83, 0xF8, 0x00, 0x5D, 0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5A, 0x59, 0x58, 0x0F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x66, 0x48,
            0x0F, 0x6E, 0xC0, 0x48, 0x8B, 0x5D, 0xF8, 0x48, 0x89, 0xEC, 0x5D, 0x5E, 0x48, 0x89, 0xDC, 0xFF, 0xE6,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 //detour address
        };

        AllocatedAssembly = MemoryModule::AllocateNearbyMemory(Target, HOOK_SIZE + sizeof(Assembly), PAGE_EXECUTE_READWRITE);
        if (!AllocatedAssembly)
        {
            return;
        }

        int32_t JMPBackDelta = (int32_t)(Target + HOOK_SIZE - (AllocatedAssembly + HOOK_SIZE + JE_OFFSET + JE_SIZE));
        *(int32_t*)(Assembly + JE_OFFSET + 2) = JMPBackDelta;

        *(i2iDetourT*)(Assembly + DETOUR_ADDRESS_OFFSET) = Detour;

        memcpy(AllocatedAssembly, Target, HOOK_SIZE);
        memcpy(AllocatedAssembly + HOOK_SIZE, Assembly, sizeof(Assembly));

        DWORD OriginalVP = 0;

        VirtualProtect(AllocatedAssembly, HOOK_SIZE + sizeof(Assembly), PAGE_EXECUTE_READ, &OriginalVP);
        VirtualProtect(Target, JMP_SIZE, PAGE_EXECUTE_READWRITE, &OriginalVP);

        Target[0] = 0xE9U;

        int32_t JMPDetourDelta = (int32_t)(AllocatedAssembly - (Target + JMP_SIZE));
        *(int32_t*)(Target + 1) = JMPDetourDelta;

        VirtualProtect(Target, JMP_SIZE, OriginalVP, &OriginalVP);

        IsError = false;
    }

    ~Midi2iHook()
    {
        if (IsError)
            return;

        DWORD Original = 0;
        if (Target[0] == 0xE9U && VirtualProtect(Target, 5, PAGE_EXECUTE_READWRITE, &Original))
        {
            memcpy(Target, AllocatedAssembly, 5);
            VirtualProtect(Target, 5, Original, &Original);
        }

        VirtualFree(AllocatedAssembly, 0, MEM_RELEASE);
    }

    bool IsError = true;
private:
    uint8_t* Target = nullptr;
    uint8_t* AllocatedAssembly = nullptr;
};

#include "src/cheat/raid0.hpp"

class JavaHook
{
private:
    static void* FindCorrectHookPlace(void* i2iEntry)
    {
        uint8_t pattern[] =
        {
            0x89, 0x84, 0x24, 0x90, 0x90, 0x90, 0x90,
            0x89, 0x84, 0x24, 0x90, 0x90, 0x90, 0x90,
            0x89, 0x84, 0x24, 0x90, 0x90, 0x90, 0x90,
            0x89, 0x84, 0x24, 0x90, 0x90, 0x90, 0x90,
            0x41, 0xC6, 0x87, 0x90, 0x90, 0x90, 0x90, 0x00
        };

        uint8_t pattern2[] =
        {
            0x4C, 0x8B, 0x75, 0x90, 0xC3
        };

        uint8_t* curr = (uint8_t*)i2iEntry;
        while (curr < (uint8_t*)i2iEntry + 0x350)
        {
            int matches = 0;
            for (int i = 0; i < sizeof(pattern); ++i)
            {
                if (pattern[i] == 0x90 || pattern[i] == curr[i])
                    matches++;
                else
                    break;
            }
            if (matches == sizeof(pattern))
            {
                for (uint8_t* curr2 = curr; curr2 > curr - 100; --curr2)
                {
                    int matches2 = 0;
                    for (int j = 0; j < sizeof(pattern2); ++j)
                    {
                        if (pattern2[j] == 0x90 || pattern2[j] == curr2[j])
                            matches2++;
                        else
                            break;
                    }
                    if (matches2 == sizeof(pattern2))
                        Frame::LocalsOffset = *(char*)(curr2 + 3);

                }
                return curr + sizeof(pattern) - 8;
            }
            curr += 1;
        }

        //8: sizeof : mov    BYTE PTR [r15+_do_not_unlock_if_synchronized_offset],0x0
        //we place the hook here because enough size and correct time
        return nullptr;
    }
    static void CommonDetour(Frame* Frame, Thread* Thread, bool* ShouldCancel)
    {
        if (!(*(void**)Thread->GetEnv()) || Thread->GetThreadState() != _THREAD_InJava) return;
        for (HookedMethod& hk : HookedMethods)
        {
            if (hk.Method == Frame->GetMethod())
            {
                hk.Detour(Frame, Thread, ShouldCancel);
                Thread->SetThreadState(_THREAD_InJava);
                return;
            }
        }
    }

    struct i2iHookData
    {
        void* i2iEntry = nullptr;
        Midi2iHook* Hook = nullptr;
    };

    inline static std::vector<i2iHookData> Hookedi2iEntries;

    struct HookedMethod
    {
        Method* Method = nullptr;
        i2iDetourT Detour = nullptr;
    };

    inline static std::vector<HookedMethod> HookedMethods;

public:
    static constexpr int NO_COMPILE = JVM_ACC_NOT_C2_COMPILABLE | JVM_ACC_NOT_C1_COMPILABLE | JVM_ACC_NOT_C2_OSR_COMPILABLE | JVM_ACC_QUEUED;

    bool Initialize()
    {
        return InitializeHotspot();
    }

    void DestroyHook()
    {
        for (i2iHookData& HookedEntries : Hookedi2iEntries)
        {
            delete HookedEntries.Hook;
        }
        for (HookedMethod& HookedMethods : HookedMethods)
        {
            HookedMethods.Method->SetDontInline(false);

            int* Flags = (int*)HookedMethods.Method->GetAccessFlags();
            *Flags &= ~(NO_COMPILE);
        }
    }

    template <typename T> inline void SetReturnValue(bool* Cancel, T ReturnValue)
    {
        *(T*)((void**)Cancel + 8) = ReturnValue; //see asm code to understand that
    }

    //param from left to right (arg0 beeing this for non static methods)
    template <typename T> inline T get_primitive_param_at(Frame* frame, int index)
    {
        return *(T*)(frame->GetLocals() - index);
    }

    inline jobject GetObjectParam(Frame* frame, int index)
    {
        return (jobject)(frame->GetLocals() - index);
    }

    bool CreateHook(jmethodID MethodID, i2iDetourT Detour)
    {
        static int SetJvmtiCapabilities = []()->int
        {
            jvmtiCapabilities Capabilities{ .can_retransform_classes = JVMTI_ENABLE };
            InstancePtr->GetJvmtiEnv()->AddCapabilities(&Capabilities);

            return 0;
        }();

        if (!MethodID || !Detour) {
            return false;
        }

        Method* Method = *(::Method**)MethodID;
        for (HookedMethod& HookedMethods : HookedMethods)
        {
            if (HookedMethods.Method == Method) {
                return true;
            }
        }

        Method->SetDontInline(true);

        int* Flags = (int*)Method->GetAccessFlags();
        *Flags |= (NO_COMPILE);

        jclass Owner = nullptr;
        InstancePtr->GetJvmtiEnv()->GetMethodDeclaringClass(MethodID, &Owner);
        InstancePtr->GetJvmtiEnv()->RetransformClasses(1, &Owner); //small trick to delete any already compiled / inlined code
        InstancePtr->GetJniEnv()->DeleteLocalRef(Owner);

        Method = *(::Method**)MethodID;

        Method->SetDontInline(true);
        Flags = (int*)Method->GetAccessFlags();
        *Flags |= (NO_COMPILE);


        HookedMethods.push_back({ Method, Detour });

        bool HookNewi2i = true;
        void* i2i = Method->Geti2iEntry();

        std::cout <<"$> Detouring " << Method->GetName() /*<< "->" << Detour*/ << std::endl;

        for (i2iHookData& i2iHook : Hookedi2iEntries)
        {
            if (i2iHook.i2iEntry == i2i) {
                HookNewi2i = false;
            }
        }


        if (!HookNewi2i) {
            return true;
        }

        uint8_t* Target = (uint8_t*)FindCorrectHookPlace(i2i);
        if (!Target)
        {
            return false;
        }

        std::cout << "i2i: " << (void*)Target << '\n';

        Midi2iHook* Hooked = new Midi2iHook(Target, CommonDetour);

        if (!Hooked) {
            return false;
        }

        Hookedi2iEntries.push_back({ i2i, Hooked });

        return true;
    }
};

inline std::unique_ptr<JavaHook> HookManager;